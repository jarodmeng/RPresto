[{"path":"https://github.com/prestodb/RPresto/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Code of Conduct","title":"Code of Conduct","text":"Facebook adopted Code Conduct expect project participants adhere . Please read full text can understand actions tolerated.","code":""},{"path":"https://github.com/prestodb/RPresto/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to RPresto","title":"Contributing to RPresto","text":"love help making RPresto better. actively welcome pull requests. 1. Fork repo create branch master. 2. ’ve added code tested, add tests 3. ’ve changed APIs, update documentation. 4. Ensure test suite passes. 5. haven’t already, complete Contributor License Agreement (“CLA”).","code":""},{"path":"https://github.com/prestodb/RPresto/CONTRIBUTING.html","id":"our-development-process","dir":"","previous_headings":"","what":"Our Development Process","title":"Contributing to RPresto","text":"develop code using devtools package. can use ‘devtools::check’ function build verify changes working intended.","code":""},{"path":"https://github.com/prestodb/RPresto/CONTRIBUTING.html","id":"contributor-license-agreement-cla","dir":"","previous_headings":"","what":"Contributor License Agreement (“CLA”)","title":"Contributing to RPresto","text":"order accept pull request, need submit CLA. need work Facebook’s open source projects. Complete CLA : https://code.facebook.com/cla","code":""},{"path":"https://github.com/prestodb/RPresto/CONTRIBUTING.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Contributing to RPresto","text":"use GitHub issues track public bugs. Please ensure description clear sufficient instructions able reproduce issue. Facebook bounty program safe disclosure security bugs. cases, please go process outlined page file public issue.","code":""},{"path":"https://github.com/prestodb/RPresto/CONTRIBUTING.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Contributing to RPresto","text":"contributing RPresto, agree contributions licensed BSD license.","code":""},{"path":"https://github.com/prestodb/RPresto/articles/common-table-expressions.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Common Table Expressions (CTEs)","text":"can check RPresto version running packageVersion() function. need version 1.4.0 later use CTE feature.","code":"library(RPresto) library(DBI) library(dplyr) library(dbplyr) packageVersion(\"RPresto\") #> [1] '1.4.0'"},{"path":"https://github.com/prestodb/RPresto/articles/common-table-expressions.html","id":"define-ctes-while-creating-a-prestoconnection","dir":"Articles","previous_headings":"","what":"Define CTEs while creating a PrestoConnection","title":"Common Table Expressions (CTEs)","text":"can define attach CTEs creating PrestoConnection. assume user already Presto server memory connector set . don’t server set , refer Presto documentation instructions want follow along. Now dummy_values existing permanent table available PrestoConnection. exists temporary feature connection. can read content CTE. can also execute arbitrary SELECT queries top CTE.","code":"con <- DBI::dbConnect(   drv = RPresto::Presto(),   host = \"http://localhost\",   port = 8080,   user = Sys.getenv(\"USER\"),   catalog = \"memory\",   schema = \"default\",   # Define a testing CTE using dummy VALUES   ctes = list(     \"dummy_values\" =       \"SELECT * FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c') ) AS t (id, name)\"   ) ) db_has_table(con, \"dummy_values\") #> [1] FALSE dbReadTable(con, \"dummy_values\") #> # A tibble: 3 × 2 #>      id name  #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c dbGetQuery(con, \"SELECT id * 2 AS id_2, name FROM dummy_values\") #> # A tibble: 3 × 2 #>    id_2 name  #>   <int> <chr> #> 1     2 a     #> 2     4 b     #> 3     6 c"},{"path":"https://github.com/prestodb/RPresto/articles/common-table-expressions.html","id":"incorporating-ctes-with-dplyr-backend","dir":"Articles","previous_headings":"","what":"Incorporating CTEs with dplyr backend","title":"Common Table Expressions (CTEs)","text":"Another way leveraging CTEs workflow incorporate dplyr workflow. call dplyr verbs remote table mimic typical analysis work flow. can see underlying SQL query generated far. illustration, let’s say filter transformed table twice cyl field UNION together next step. underlying SQL query transformed table (.e. tbl.mtcars.transform) replicated twice step thus makes resulting query long repetitive. offers prime opportunity simplify using CTEs. can “save” underlying SQL query transformed table CTE use union step calling compute() function cte = TRUE. content tbl.mtcars.transform hasn’t changed can use remote table just like . change underneath underlying logic now captured stored CTE. can almost think saving tbl.mtcars.transform temporary table named mtcars_transform pointing new remote table temporary table. difference query actually executed yet. Now ’ve leveraged CTE, query union step looks clean readable. can even create nested CTEs depend CTEs (Presto calls chained CTEs). call compute() tbl.mtcars.union already utilizies mtcars_transform CTE. Now underlying query previous tbl.mtcars.union saved mtcars_union CTE turn depends mtcars_transform CTE.","code":"# We first copy mtcars to Presto and create a remote table on it tbl.mtcars <- copy_to(con, mtcars, \"test_mtcars\", overwrite = TRUE) tbl.mtcars %>% colnames() #>  [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\" #> [11] \"carb\" tbl.mtcars.transform <- tbl.mtcars %>%   mutate(hp2 = pow(hp, 2)) %>%   group_by(cyl) %>%   mutate(mean_mpg_by_cyl = mean(mpg, na.rm = TRUE)) tbl.mtcars.transform %>% show_query() #> <SQL> #> SELECT *, AVG(\"mpg\") OVER (PARTITION BY \"cyl\") AS \"mean_mpg_by_cyl\" #> FROM ( #>   SELECT *, pow(\"hp\", 2.0) AS \"hp2\" #>   FROM \"test_mtcars\" #> ) \"q01\" tbl.mtcars.union <- union(   filter(tbl.mtcars.transform, cyl == 4L),   filter(tbl.mtcars.transform, cyl == 8L),   all = TRUE ) tbl.mtcars.union %>% show_query() #> <SQL> #> ( #>   SELECT * #>   FROM ( #>     SELECT *, AVG(\"mpg\") OVER (PARTITION BY \"cyl\") AS \"mean_mpg_by_cyl\" #>     FROM ( #>       SELECT *, pow(\"hp\", 2.0) AS \"hp2\" #>       FROM \"test_mtcars\" #>     ) \"q01\" #>   ) \"q02\" #>   WHERE (\"cyl\" = 4) #> ) #> UNION ALL #> ( #>   SELECT * #>   FROM ( #>     SELECT *, AVG(\"mpg\") OVER (PARTITION BY \"cyl\") AS \"mean_mpg_by_cyl\" #>     FROM ( #>       SELECT *, pow(\"hp\", 2.0) AS \"hp2\" #>       FROM \"test_mtcars\" #>     ) \"q03\" #>   ) \"q04\" #>   WHERE (\"cyl\" = 8) #> ) tbl.mtcars.transform <- tbl.mtcars.transform %>%   compute(name = \"mtcars_transform\", cte = TRUE) tbl.mtcars.transform %>% show_query() #> <SQL> #> WITH \"mtcars_transform\" AS ( #> SELECT *, AVG(\"mpg\") OVER (PARTITION BY \"cyl\") AS \"mean_mpg_by_cyl\" #> FROM ( #>   SELECT *, pow(\"hp\", 2.0) AS \"hp2\" #>   FROM \"test_mtcars\" #> ) \"q01\" #> ) #> SELECT * #> FROM \"mtcars_transform\" tbl.mtcars.union <- union(   filter(tbl.mtcars.transform, cyl == 4L),   filter(tbl.mtcars.transform, cyl == 8L),   all = TRUE ) tbl.mtcars.union %>% show_query() #> <SQL> #> WITH \"mtcars_transform\" AS ( #> SELECT *, AVG(\"mpg\") OVER (PARTITION BY \"cyl\") AS \"mean_mpg_by_cyl\" #> FROM ( #>   SELECT *, pow(\"hp\", 2.0) AS \"hp2\" #>   FROM \"test_mtcars\" #> ) \"q01\" #> ) #> ( #>   SELECT * #>   FROM \"mtcars_transform\" #>   WHERE (\"cyl\" = 4) #> ) #> UNION ALL #> ( #>   SELECT * #>   FROM \"mtcars_transform\" #>   WHERE (\"cyl\" = 8) #> ) tbl.mtcars.union <- tbl.mtcars.union %>%   compute(name = \"mtcars_union\", cte = TRUE) tbl.mtcars.union %>% show_query() #> <SQL> #> WITH \"mtcars_transform\" AS ( #> SELECT *, AVG(\"mpg\") OVER (PARTITION BY \"cyl\") AS \"mean_mpg_by_cyl\" #> FROM ( #>   SELECT *, pow(\"hp\", 2.0) AS \"hp2\" #>   FROM \"test_mtcars\" #> ) \"q01\" #> ), #> \"mtcars_union\" AS ( #> ( #>   SELECT * #>   FROM \"mtcars_transform\" #>   WHERE (\"cyl\" = 4) #> ) #> UNION ALL #> ( #>   SELECT * #>   FROM \"mtcars_transform\" #>   WHERE (\"cyl\" = 8) #> ) #> ) #> SELECT * #> FROM \"mtcars_union\""},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"package-setup","dir":"Articles","previous_headings":"","what":"Package setup","title":"Translating complex Presto data types","text":"can check RPresto version running packageVersion() function. need version 1.3.9 later comprehensive robust complex types support.","code":"library(RPresto) packageVersion(\"RPresto\") #> [1] '1.4.0'"},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Translating complex Presto data types","text":"Complex types refer structural types including ARRAY, MAP ROW. data types basically containers hold data types (hence complex). summarize similarities differences complex types . Atomic means elements container share type (usually primitive types, can complex types ). example, ARRAY integer can hold integer type elements whereas ROW can elements different types (e.g., one element integer boolean).","code":""},{"path":[]},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"local-presto-server-in-memory","dir":"Articles","previous_headings":"Walkthrough preparation","what":"Local Presto server in memory","title":"Translating complex Presto data types","text":"assume user already Presto server memory connector set . don’t server set , refer Presto documentation instructions want follow along.","code":""},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"presto-connection-in-r","dir":"Articles","previous_headings":"Walkthrough preparation","what":"Presto connection in R","title":"Translating complex Presto data types","text":"first create PrestoConnection serve bridge Presto server R. first issue simple query see Presto connection working properly.","code":"con <- DBI::dbConnect(   drv = RPresto::Presto(),   host = \"http://localhost\",   port = 8080,   user = Sys.getenv(\"USER\"),   catalog = \"memory\",   schema = \"default\" ) DBI::dbGetQuery(con, \"SELECT 1+1 AS res\") #> # A tibble: 1 × 1 #>     res #>   <int> #> 1     2"},{"path":[]},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"arrays","dir":"Articles","previous_headings":"Atomic structural types that contain primitive types","what":"ARRAYs","title":"Translating complex Presto data types","text":"Given atomic unnamed nature ARRAYs, map unnamed typed vectors R.","code":""},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"create-a-table-with-arrays-of-primitive-types","dir":"Articles","previous_headings":"Atomic structural types that contain primitive types > ARRAYs","what":"Create a table with ARRAYs of primitive types","title":"Translating complex Presto data types","text":"first create table ARRAYs supported primitive Presto data types using create_primitive_arrays_table() function included RPresto package. can check table now exists Presto. can list fields table. named Presto types represent.","code":"RPresto:::create_primitive_arrays_table(   con, table_name = \"presto_primitive_arrays\", verbose = FALSE ) DBI::dbExistsTable(con, \"presto_primitive_arrays\") #> [1] TRUE DBI::dbListFields(con, \"presto_primitive_arrays\") #>  [1] \"array_boolean\"                \"array_tinyint\"                #>  [3] \"array_smallint\"               \"array_integer\"                #>  [5] \"array_bigint\"                 \"array_real\"                   #>  [7] \"array_double\"                 \"array_varchar\"                #>  [9] \"array_char\"                   \"array_varbinary\"              #> [11] \"array_date\"                   \"array_time\"                   #> [13] \"array_time_with_tz\"           \"array_timestamp\"              #> [15] \"array_timestamp_with_tz\"      \"array_interval_year_to_month\" #> [17] \"array_interval_day_to_second\""},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"translate-arrays-to-r-vectors","dir":"Articles","previous_headings":"Atomic structural types that contain primitive types > ARRAYs","what":"Translate ARRAYs to R vectors","title":"Translating complex Presto data types","text":"can verify R types column. vectors unnamed. can also call functions length() columns get ARRAY cardinality. shows ARRAYs 3 elements .","code":"(   df.array_of_primitive_types <- dbGetQuery(     con,     \"SELECT * FROM presto_primitive_arrays\",     bigint = \"integer64\"   ) ) #> # A tibble: 1 × 17 #>   array_boolean array_…¹ array…² array…³ array…⁴ array…⁵ array…⁶ array…⁷ array…⁸ #>   <list>        <list>   <list>  <list>  <list>  <list>  <list>  <list>  <list>  #> 1 <lgl [3]>     <int>    <int>   <int>   <int64> <dbl>   <dbl>   <chr>   <chr>   #> # … with 8 more variables: array_varbinary <list>, array_date <list>, #> #   array_time <list>, array_time_with_tz <list>, array_timestamp <list>, #> #   array_timestamp_with_tz <list>, array_interval_year_to_month <list>, #> #   array_interval_day_to_second <list>, and abbreviated variable names #> #   ¹​array_tinyint, ²​array_smallint, ³​array_integer, ⁴​array_bigint, #> #   ⁵​array_real, ⁶​array_double, ⁷​array_varchar, ⁸​array_char tibble::enframe(purrr::map_chr(df.array_of_primitive_types, ~class(.[[1]])[1])) #> # A tibble: 17 × 2 #>    name                         value     #>    <chr>                        <chr>     #>  1 array_boolean                logical   #>  2 array_tinyint                integer   #>  3 array_smallint               integer   #>  4 array_integer                integer   #>  5 array_bigint                 integer64 #>  6 array_real                   numeric   #>  7 array_double                 numeric   #>  8 array_varchar                character #>  9 array_char                   character #> 10 array_varbinary              list      #> 11 array_date                   Date      #> 12 array_time                   hms       #> 13 array_time_with_tz           hms       #> 14 array_timestamp              POSIXct   #> 15 array_timestamp_with_tz      POSIXct   #> 16 array_interval_year_to_month Duration  #> 17 array_interval_day_to_second Duration purrr::every(df.array_of_primitive_types, ~is.null(names(.[[1]]))) #> [1] TRUE tibble::enframe(purrr::map_int(df.array_of_primitive_types, ~length(.[[1]]))) #> # A tibble: 17 × 2 #>    name                         value #>    <chr>                        <int> #>  1 array_boolean                    3 #>  2 array_tinyint                    3 #>  3 array_smallint                   3 #>  4 array_integer                    3 #>  5 array_bigint                     3 #>  6 array_real                       3 #>  7 array_double                     3 #>  8 array_varchar                    3 #>  9 array_char                       3 #> 10 array_varbinary                  3 #> 11 array_date                       3 #> 12 array_time                       3 #> 13 array_time_with_tz               3 #> 14 array_timestamp                  3 #> 15 array_timestamp_with_tz          3 #> 16 array_interval_year_to_month     3 #> 17 array_interval_day_to_second     3"},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"maps","dir":"Articles","previous_headings":"Atomic structural types that contain primitive types","what":"MAPs","title":"Translating complex Presto data types","text":"MAP Presto can thought combination two -length ARRAYs. first ARRAY contains keys MAP second contains values MAP. fact, ’s exactly MAP literals created Presto (e.g., MAP(ARRAY[1, 2], ARRAY['', 'b']) creates 2-element MAP). Following logic, translate MAPs named typed vectors R.","code":""},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"create-a-table-with-maps-of-primitive-types","dir":"Articles","previous_headings":"Atomic structural types that contain primitive types > MAPs","what":"Create a table with MAPS of primitive types","title":"Translating complex Presto data types","text":"first create table MAPSs supported primitive Presto data types using create_primitive_maps_table() function included RPresto package. can check table now exists Presto. can list fields table. named Presto types represent.","code":"RPresto:::create_primitive_maps_table(   con, table_name = \"presto_primitive_maps\", verbose = FALSE ) DBI::dbExistsTable(con, \"presto_primitive_maps\") #> [1] TRUE DBI::dbListFields(con, \"presto_primitive_maps\") #>  [1] \"map_boolean\"                \"map_tinyint\"                #>  [3] \"map_smallint\"               \"map_integer\"                #>  [5] \"map_bigint\"                 \"map_real\"                   #>  [7] \"map_double\"                 \"map_varchar\"                #>  [9] \"map_char\"                   \"map_varbinary\"              #> [11] \"map_date\"                   \"map_time\"                   #> [13] \"map_time_with_tz\"           \"map_timestamp\"              #> [15] \"map_timestamp_with_tz\"      \"map_interval_year_to_month\" #> [17] \"map_interval_day_to_second\""},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"translate-maps-to-r-vectors","dir":"Articles","previous_headings":"Atomic structural types that contain primitive types > MAPs","what":"Translate MAPs to R vectors","title":"Translating complex Presto data types","text":"can verify R types column. vectors named.","code":"(   df.map_of_primitive_types <- dbGetQuery(     con,     \"SELECT * FROM presto_primitive_maps\",     bigint = \"integer64\"   ) ) #> # A tibble: 1 × 17 #>   map_boolean map_tiny…¹ map_s…² map_i…³ map_b…⁴ map_r…⁵ map_d…⁶ map_v…⁷ map_c…⁸ #>   <list>      <list>     <list>  <list>  <list>  <list>  <list>  <list>  <list>  #> 1 <lgl [3]>   <int [3]>  <int>   <int>   <int64> <dbl>   <dbl>   <chr>   <chr>   #> # … with 8 more variables: map_varbinary <list>, map_date <list>, #> #   map_time <list>, map_time_with_tz <list>, map_timestamp <list>, #> #   map_timestamp_with_tz <list>, map_interval_year_to_month <list>, #> #   map_interval_day_to_second <list>, and abbreviated variable names #> #   ¹​map_tinyint, ²​map_smallint, ³​map_integer, ⁴​map_bigint, ⁵​map_real, #> #   ⁶​map_double, ⁷​map_varchar, ⁸​map_char tibble::enframe(purrr::map_chr(df.map_of_primitive_types, ~class(.[[1]])[1])) #> # A tibble: 17 × 2 #>    name                       value     #>    <chr>                      <chr>     #>  1 map_boolean                logical   #>  2 map_tinyint                integer   #>  3 map_smallint               integer   #>  4 map_integer                integer   #>  5 map_bigint                 integer64 #>  6 map_real                   numeric   #>  7 map_double                 numeric   #>  8 map_varchar                character #>  9 map_char                   character #> 10 map_varbinary              list      #> 11 map_date                   Date      #> 12 map_time                   hms       #> 13 map_time_with_tz           hms       #> 14 map_timestamp              POSIXct   #> 15 map_timestamp_with_tz      POSIXct   #> 16 map_interval_year_to_month Duration  #> 17 map_interval_day_to_second Duration purrr::none(df.map_of_primitive_types, ~is.null(names(.[[1]]))) #> [1] TRUE"},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"repeated-arrays-and-maps","dir":"Articles","previous_headings":"Atomic structural types that contain primitive types","what":"Repeated ARRAYs and MAPs","title":"Translating complex Presto data types","text":"’s possible repeated ARRAYs MAPs Presto form ARRAYs ARRAYs ARRAYs MAPs. supporting nested ARRAYs moment although ’s technically possible Presto. ARRAYs MAPs, translate ARRAY container unnamed list MAP element named typed vector. first create array--maps table using create_array_of_maps_table() function. can check table now exists Presto. can list fields table. Let’s import data R. need pry open wrapping unnamed list reveal types vectors underneath.","code":"RPresto:::create_array_of_maps_table(   con, table_name = \"presto_array_of_maps\", verbose = FALSE ) DBI::dbExistsTable(con, \"presto_array_of_maps\") #> [1] TRUE DBI::dbListFields(con, \"presto_array_of_maps\") #>  [1] \"array_map_boolean\"                \"array_map_tinyint\"                #>  [3] \"array_map_smallint\"               \"array_map_integer\"                #>  [5] \"array_map_bigint\"                 \"array_map_real\"                   #>  [7] \"array_map_double\"                 \"array_map_varchar\"                #>  [9] \"array_map_char\"                   \"array_map_varbinary\"              #> [11] \"array_map_date\"                   \"array_map_time\"                   #> [13] \"array_map_time_with_tz\"           \"array_map_timestamp\"              #> [15] \"array_map_timestamp_with_tz\"      \"array_map_interval_year_to_month\" #> [17] \"array_map_interval_day_to_second\" (   df.array_of_maps <- dbGetQuery(     con,     \"SELECT * FROM presto_primitive_maps\",     bigint = \"integer64\"   ) ) #> # A tibble: 1 × 17 #>   map_boolean map_tiny…¹ map_s…² map_i…³ map_b…⁴ map_r…⁵ map_d…⁶ map_v…⁷ map_c…⁸ #>   <list>      <list>     <list>  <list>  <list>  <list>  <list>  <list>  <list>  #> 1 <lgl [3]>   <int [3]>  <int>   <int>   <int64> <dbl>   <dbl>   <chr>   <chr>   #> # … with 8 more variables: map_varbinary <list>, map_date <list>, #> #   map_time <list>, map_time_with_tz <list>, map_timestamp <list>, #> #   map_timestamp_with_tz <list>, map_interval_year_to_month <list>, #> #   map_interval_day_to_second <list>, and abbreviated variable names #> #   ¹​map_tinyint, ²​map_smallint, ³​map_integer, ⁴​map_bigint, ⁵​map_real, #> #   ⁶​map_double, ⁷​map_varchar, ⁸​map_char tibble::enframe(purrr::map_chr(df.array_of_maps, ~class(.[[1]][[1]])[1])) #> # A tibble: 17 × 2 #>    name                       value     #>    <chr>                      <chr>     #>  1 map_boolean                logical   #>  2 map_tinyint                integer   #>  3 map_smallint               integer   #>  4 map_integer                integer   #>  5 map_bigint                 integer64 #>  6 map_real                   numeric   #>  7 map_double                 numeric   #>  8 map_varchar                character #>  9 map_char                   character #> 10 map_varbinary              raw       #> 11 map_date                   Date      #> 12 map_time                   hms       #> 13 map_time_with_tz           hms       #> 14 map_timestamp              POSIXct   #> 15 map_timestamp_with_tz      POSIXct   #> 16 map_interval_year_to_month Duration  #> 17 map_interval_day_to_second Duration"},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"row-type","dir":"Articles","previous_headings":"","what":"ROW type","title":"Translating complex Presto data types","text":"easiest way think ROW type Presto think literally row table. Just table can multiple columns different data types, ROW can multiple elements different types. just like table name column, every element ROW name associated value. Depending whether ROW type repeated (.e., wrapped ARRAY), translation R different. translate single ROW value named list R. Rather interpret repeated ROWs (.e., ARRAY ROWs) list named lists, translate collection ROWs tibble.","code":""},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"single-row-translation","dir":"Articles","previous_headings":"ROW type","what":"Single ROW translation","title":"Translating complex Presto data types","text":"demonstrate ROW types translated R types, first create table using auxiliary create_primitive_rows_table() function included package. resulting table 1 column named row_primitive_types ROW includes 17 sub-columns representing supported primitive types. can check table now exists Presto. can list fields table. can retrieve data table. can check R types element named list.","code":"RPresto:::create_primitive_rows_table(   con, table_name = \"presto_primitive_rows\", verbose = FALSE ) DBI::dbExistsTable(con, \"presto_primitive_rows\") #> [1] TRUE DBI::dbListFields(con, \"presto_primitive_rows\") #> [1] \"row_primitive_types\" (   df.row_of_primitive <- dbGetQuery(     con,     \"SELECT row_primitive_types FROM presto_primitive_rows\",     bigint = \"integer64\"   ) ) #> # A tibble: 3 × 1 #>   row_primitive_types #>   <list>              #> 1 <named list [17]>   #> 2 <named list [17]>   #> 3 <named list [17]> tibble::enframe(   purrr::map_chr(df.row_of_primitive$row_primitive_types[[1]], ~class(.)[1]) ) #> # A tibble: 17 × 2 #>    name                   value     #>    <chr>                  <chr>     #>  1 boolean                logical   #>  2 tinyint                integer   #>  3 smallint               integer   #>  4 integer                integer   #>  5 bigint                 integer64 #>  6 real                   numeric   #>  7 double                 numeric   #>  8 varchar                character #>  9 char                   character #> 10 varbinary              list      #> 11 date                   Date      #> 12 time                   hms       #> 13 time_with_tz           hms       #> 14 timestamp              POSIXct   #> 15 timestamp_with_tz      POSIXct   #> 16 interval_year_to_month Duration  #> 17 interval_day_to_second Duration"},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"repeated-rows-translation","dir":"Articles","previous_headings":"ROW type","what":"Repeated ROWs translation","title":"Translating complex Presto data types","text":"construct repeated ROW column, use auxiliary create_array_of_rows_table() function. can check table now exists Presto field name. can import whole data R. can verify tibble’s column types.","code":"RPresto:::create_array_of_rows_table(   con, table_name = \"presto_array_of_rows\", verbose = FALSE ) DBI::dbExistsTable(con, \"presto_array_of_rows\") #> [1] TRUE DBI::dbListFields(con, \"presto_array_of_rows\") #> [1] \"array_of_rows\" (   df.array_of_rows <- dbGetQuery(     con,     \"SELECT array_of_rows FROM presto_array_of_rows\",     bigint = \"integer64\"   ) ) #> # A tibble: 3 × 1 #>   array_of_rows     #>   <list>            #> 1 <tibble [2 × 17]> #> 2 <tibble [2 × 17]> #> 3 <tibble [2 × 17]> tibble::enframe(   purrr::map_chr(df.array_of_rows$array_of_rows[[1]], ~class(.)[1]) ) #> # A tibble: 17 × 2 #>    name                   value     #>    <chr>                  <chr>     #>  1 boolean                logical   #>  2 tinyint                integer   #>  3 smallint               integer   #>  4 integer                integer   #>  5 bigint                 integer64 #>  6 real                   numeric   #>  7 double                 numeric   #>  8 varchar                character #>  9 char                   character #> 10 varbinary              list      #> 11 date                   Date      #> 12 time                   hms       #> 13 time_with_tz           hms       #> 14 timestamp              POSIXct   #> 15 timestamp_with_tz      POSIXct   #> 16 interval_year_to_month Duration  #> 17 interval_day_to_second Duration"},{"path":"https://github.com/prestodb/RPresto/articles/complex-types.html","id":"walkthrough-wrap-up","dir":"Articles","previous_headings":"","what":"Walkthrough wrap-up","title":"Translating complex Presto data types","text":"","code":"DBI::dbDisconnect(con) #> [1] TRUE"},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"package-setup","dir":"Articles","previous_headings":"","what":"Package setup","title":"Primitive Presto data types to R types","text":"can check RPresto version running packageVersion() function. need version 1.3.9 later comprehensive robust primitive types support.","code":"library(RPresto) packageVersion(\"RPresto\") #> [1] '1.4.0'"},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Primitive Presto data types to R types","text":"primitive types refer basic data types atomic non-nested (opposed structural types ARRAY, MAP, ROW). Refer Presto documentation complete list Presto data types. don’t currently support Presto’s primitive types. summarize ’s supported supported types map R.","code":""},{"path":[]},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"local-presto-server-in-memory","dir":"Articles","previous_headings":"Walkthrough preparation","what":"Local Presto server in memory","title":"Primitive Presto data types to R types","text":"assume user already Presto server memory connector set . don’t server set , refer Presto documentation instructions want follow along.","code":""},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"presto-connection-in-r","dir":"Articles","previous_headings":"Walkthrough preparation","what":"Presto connection in R","title":"Primitive Presto data types to R types","text":"first create PrestoConnection serve bridge Presto server R. first issue simple query see Presto connection working properly.","code":"con <- DBI::dbConnect(   drv = RPresto::Presto(),   host = \"http://localhost\",   port = 8080,   user = Sys.getenv(\"USER\"),   catalog = \"memory\",   schema = \"default\" ) DBI::dbGetQuery(con, \"SELECT 1+1 AS res\") #> # A tibble: 1 × 1 #>     res #>   <int> #> 1     2"},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"primitive-data-types-table-in-presto","dir":"Articles","previous_headings":"Walkthrough preparation","what":"Primitive data types table in Presto","title":"Primitive Presto data types to R types","text":"illustrate primitive types mapped R types bulk, first create made-table 3 rows 17 fields (.e., one column supported Presto type). create table using auxiliary create_primitive_types_table() function included package. can check table now exists Presto. can list fields table. named Presto types represent.","code":"RPresto:::create_primitive_types_table(   con, table_name = \"presto_primitive_types\", verbose = FALSE ) DBI::dbExistsTable(con, \"presto_primitive_types\") #> [1] TRUE DBI::dbListFields(con, \"presto_primitive_types\") #>  [1] \"boolean\"                \"tinyint\"                \"smallint\"               #>  [4] \"integer\"                \"bigint\"                 \"real\"                   #>  [7] \"double\"                 \"varchar\"                \"char\"                   #> [10] \"varbinary\"              \"date\"                   \"time\"                   #> [13] \"time_with_tz\"           \"timestamp\"              \"timestamp_with_tz\"      #> [16] \"interval_year_to_month\" \"interval_day_to_second\""},{"path":[]},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"boolean","dir":"Articles","previous_headings":"Data types mapping to R","what":"Boolean","title":"Primitive Presto data types to R types","text":"Translating boolean values Presto R fairly straightforward. true false values mapped TRUE FALSE R null mapped NA default logical (.e., boolean) type R. can verify three values R logical.","code":"(   df.boolean <- dbGetQuery(con, \"SELECT boolean FROM presto_primitive_types\") ) #> # A tibble: 3 × 1 #>   boolean #>   <lgl>   #> 1 TRUE    #> 2 FALSE   #> 3 NA purrr::map_chr(df.boolean$boolean, class) #> [1] \"logical\" \"logical\" \"logical\""},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"integers","dir":"Articles","previous_headings":"Data types mapping to R","what":"Integers","title":"Primitive Presto data types to R types","text":"Presto 4 integer data types. TINYINT 8-bit ranges -2^7 2^7-1. SMALLINT 16-bit ranges -2^15 2^15-1. INTEGER 32-bit ranges -2^31 2^31-1. BIGINT 64-bit ranges -2^63 2^63-1. comparison, base R ships one 32-bit integer type, range slightly different Presto. R’s integer type ranges -2^31+1 = -2,147,483,647 2^31-1 = 2,147,483,647. one number (~4.3 billion 32-bit integer numbers) ’s valid INTEGER Presto R range lower bound -2,147,483,648.","code":""},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"non-bigint-integers","dir":"Articles","previous_headings":"Data types mapping to R > Integers","what":"Non-BIGINT integers","title":"Primitive Presto data types to R types","text":"Since TINYINT, SMALLINT, INTEGER numbers (except -2,147,483,648) can fit R’s integer type, translate integers. can verify three columns R integer types. can also show mapping one exception -2,147,483,648 R results error query runs correctly Presto. Users whose data contains exceptional integer consider using BIGINT type rather INTEGER encode data Presto.","code":"(   df.non_bigint_int <- dbGetQuery(     con, \"SELECT tinyint, smallint, integer FROM presto_primitive_types\"   ) ) #> # A tibble: 3 × 3 #>   tinyint smallint     integer #>     <int>    <int>       <int> #> 1    -128   -32768 -2147483647 #> 2     127    32767  2147483647 #> 3      NA       NA          NA purrr::map_chr(df.non_bigint_int, class) #>   tinyint  smallint   integer  #> \"integer\" \"integer\" \"integer\" dbGetQuery(con, \"SELECT CAST('-2147483648' AS INTEGER) AS non_bigint_exception\") #> Error: Can't coerce element 1 from a double to a integer"},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"bigint-integers","dir":"Articles","previous_headings":"Data types mapping to R > Integers","what":"BIGINT integers","title":"Primitive Presto data types to R types","text":"Since Presto BIGINT type 64-bit, range clearly much wider base R’s integer type. However, default still map BIGINT integers Presto integer R, two reasons. R doesn’t native 64-bit integer support yet. Mapping BIGINT 64-bit integer R require additional package add extra dependencies. 32-bit integer range covers 2+ billion positive integers 4.3 billion integers total. integer values used data analysis modeling can well covered range. Besides default mapping integer (albeit 32-bit) type, offer three options comes BIGINT mapping. Firstly, using bigint = \"character\" argument instructs RPresto cast BIGINT value character type. particularly useful BIGINT used store long IDs rather large numbers (.e., numbers used arithmetic computations). Using bigint = \"integer64\" makes RPresto translate BIGINT values value integer64 S3 class bit64 package. bigint = \"numeric\" makes RPresto store BIGINT value numeric ( .e., double) type. Whenever map integer another numeric type, always need consider precision mapping, , whether ’s precision loss translation. Among three translation options , first one (.e., casting BIGINT character) doesn’t involve precision translation, focus precision discussion two translations ( bit64::integer64 numeric). receiving end, bit64::integer64 type range -2^63+1 = -9,223,372,036,854,775,807 2^63-1 = 9,223,372,036,854,775,807. Comparing range Presto’s BIGINT range, seems theory bit64::integer64 range infinitesimally smaller BIGINT range 1 number (, lower bound number). However, practice, range BIGINT values can translated bit64::integer64 without precision loss much smaller. limitation comes Presto REST API communicates data R. uses JSON format encode query result data sends R RPresto process. JSON default encodes integers double numbers, precision limited +/-(2^53-1) = +/-9,007,199,254,740,991. integers outside range lose precision translation. Since translation limitation caused JSON format encoding integers using double, limitation applies BIGINT values mapped numeric types R. table created create_primitive_types_table() function values -precision-lost range. show different bigint arguments change output R types. bigint = \"character\" bigint = \"integer64\" bigint = \"numeric\" attempt translate integers outside -precision-loss range, warning message show .","code":"bit64::lim.integer64() #> integer64 #> [1] -9223372036854775807 9223372036854775807 dbGetQuery(   con, \"SELECT bigint FROM presto_primitive_types\", bigint = \"character\" ) #> # A tibble: 3 × 1 #>   bigint            #>   <chr>             #> 1 -9007199254740991 #> 2 9007199254740991  #> 3 NA dbGetQuery(   con, \"SELECT bigint FROM presto_primitive_types\", bigint = \"integer64\" ) #> # A tibble: 3 × 1 #>              bigint #>             <int64> #> 1 -9007199254740991 #> 2  9007199254740991 #> 3                NA dbGetQuery(   con, \"SELECT bigint FROM presto_primitive_types\", bigint = \"numeric\" ) #> # A tibble: 3 × 1 #>              bigint #>               <dbl> #> 1 -9007199254740991 #> 2  9007199254740991 #> 3                NA dbGetQuery(   con,   \"   SELECT SIGN(bigint) * (ABS(bigint) + 1) AS bigint_precision_loss   FROM presto_primitive_types   \",   bigint = \"numeric\" ) #> Warning in as.double.integer64(x): integer precision lost while converting to #> double #> # A tibble: 3 × 1 #>   bigint_precision_loss #>                   <dbl> #> 1     -9007199254740992 #> 2      9007199254740992 #> 3                    NA"},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"floating-numbers","dir":"Articles","previous_headings":"Data types mapping to R","what":"Floating numbers","title":"Primitive Presto data types to R types","text":"R one floating point data type, double (class numeric). floating numbers stored double precision format (.e., 64-bit). matches Presto’s DOUBLE type, translation Presto R straightforward. can verify floating point types translated numeric.","code":"(   df.floating_point <- dbGetQuery(     con,     \"SELECT real, double FROM presto_primitive_types\"   ) ) #> # A tibble: 3 × 2 #>    real double #>   <dbl>  <dbl> #> 1     1      1 #> 2     2      2 #> 3    NA     NA purrr::map_chr(df.floating_point, class) #>      real    double  #> \"numeric\" \"numeric\""},{"path":[]},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"varchar-and-char-types","dir":"Articles","previous_headings":"Data types mapping to R > Strings","what":"VARCHAR and CHAR types","title":"Primitive Presto data types to R types","text":"VARCHAR CHAR data types Presto mapped R’s character type. can verify resulting R types character.","code":"(   df.characters <- dbGetQuery(     con,     \"SELECT varchar, char FROM presto_primitive_types\"   ) ) #> # A tibble: 3 × 2 #>   varchar char  #>   <chr>   <chr> #> 1 abc     a     #> 2 def     b     #> 3 NA      NA purrr::map_chr(df.characters, class) #>     varchar        char  #> \"character\" \"character\""},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"varbinary","dir":"Articles","previous_headings":"Data types mapping to R > Strings","what":"VARBINARY","title":"Primitive Presto data types to R types","text":"Presto’s VARBINARY type stores string data raw bytes. can nicely mapped R’s raw type. can verify elements resulting column raw data type. can also convert bytes data back string values.","code":"(   df.bytes <- dbGetQuery(     con,     \"SELECT varbinary FROM presto_primitive_types\"   ) ) #> # A tibble: 3 × 1 #>   varbinary #>   <list>    #> 1 <raw [3]> #> 2 <raw [3]> #> 3 <raw [0]> purrr::map_chr(df.bytes$varbinary, class) #> [1] \"raw\" \"raw\" \"raw\" dplyr::mutate(df.bytes, string = purrr::map_chr(varbinary, rawToChar)) #> # A tibble: 3 × 2 #>   varbinary string #>   <list>    <chr>  #> 1 <raw [3]> \"abc\"  #> 2 <raw [3]> \"def\"  #> 3 <raw [0]> \"\""},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"date-and-time","dir":"Articles","previous_headings":"Data types mapping to R","what":"Date and Time","title":"Primitive Presto data types to R types","text":"R, three types date/time data refer instant time. date. Tibbles print <date>. time within day. Tibbles print <time>. date-time date plus time: uniquely identifies instant time (typically nearest second). Tibbles print <dttm>. Elsewhere R called POSIXct. prefer use lubridate package handle date date-time objects. Time objects commonly used R lacks strong native support . RPresto, uses hms package handle time objects.","code":""},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"date","dir":"Articles","previous_headings":"Data types mapping to R > Date and Time","what":"DATE","title":"Primitive Presto data types to R types","text":"DATE type far used date--time types. Note DATE value isn’t tied particular time zone, isn’t associated unique point time (.e., seconds microseconds since epoch). use base R’s Date S3 class translate Presto’s DATE type. can verify R type column.","code":"(   df.date <- dbGetQuery(     con,     \"SELECT date FROM presto_primitive_types\"   ) ) #> # A tibble: 3 × 1 #>   date       #>   <date>     #> 1 2000-01-01 #> 2 2000-01-02 #> 3 NA purrr::map_chr(df.date, class) #>   date  #> \"Date\""},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"timestamp","dir":"Articles","previous_headings":"Data types mapping to R > Date and Time","what":"TIMESTAMP","title":"Primitive Presto data types to R types","text":"POSIXct type values, hand, associated unique point time. , can translated unique numeric value refers number time units (usually seconds, milliseconds, microseconds) elapsed since epoch (.e., beginning time). mode POSIXct value R numeric can call .integer() function . case, integer value refers number seconds elapsed since 1970-01-01 00:00:00 UTC time zone. Presto’s TIMESTAMP TIMESTAMP TIME ZONE types follow logic thus can mapped POSIXct type. ensure consistency, RPresto always translates timestamp match Presto session’s timezone. can check session time zone printing session.timezone slot PrestoConnection object. get TIMESTAMP TIMESTAMP TIME ZONE values table. can check R types two columns. can also verify time zone attributes match session time zone.","code":"foo <- lubridate::ymd_hms(\"2000-01-01 01:02:03\", tz = \"America/New_York\") mode(foo) #> [1] \"numeric\" as.integer(foo) #> [1] 946706523 con@session.timezone #> [1] \"Asia/Singapore\" (   df.posixct <- dbGetQuery(     con,     \"SELECT timestamp, timestamp_with_tz FROM presto_primitive_types\"   ) ) #> # A tibble: 3 × 2 #>   timestamp           timestamp_with_tz   #>   <dttm>              <dttm>              #> 1 2000-01-01 01:02:03 2000-01-01 14:02:03 #> 2 2000-01-02 02:03:04 2000-01-02 15:03:04 #> 3 NA                  NA purrr::map(df.posixct, class) #> $timestamp #> [1] \"POSIXct\" \"POSIXt\"  #>  #> $timestamp_with_tz #> [1] \"POSIXct\" \"POSIXt\" purrr::map_chr(df.posixct$timestamp, lubridate::tz) #> [1] \"Asia/Singapore\" \"Asia/Singapore\" \"Asia/Singapore\" purrr::map_chr(df.posixct$timestamp_with_tz, lubridate::tz) #> [1] \"Asia/Singapore\" \"Asia/Singapore\" \"Asia/Singapore\""},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"intervals","dir":"Articles","previous_headings":"Data types mapping to R > Date and Time","what":"INTERVALs","title":"Primitive Presto data types to R types","text":"Presto two INTERVAL types: INTERVAL YEAR MONTH INTERVAL DAY SECOND. map lubridate::Duration-class.","code":"(   df.duration <- dbGetQuery(     con,     \"     SELECT       interval_year_to_month,       interval_day_to_second     FROM presto_primitive_types     \"   ) ) #> # A tibble: 3 × 2 #>   interval_year_to_month  interval_day_to_second #>   <Duration>              <Duration>             #> 1 36817200s (~1.17 years) 187506.5s (~2.17 days) #> 2 73634400s (~2.33 years) 284889.6s (~3.3 days)  #> 3 NA                      NA"},{"path":"https://github.com/prestodb/RPresto/articles/primitive-types.html","id":"walkthrough-wrap-up","dir":"Articles","previous_headings":"","what":"Walkthrough wrap-up","title":"Primitive Presto data types to R types","text":"","code":"DBI::dbDisconnect(con) #> [1] TRUE"},{"path":"https://github.com/prestodb/RPresto/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Onur Ismail Filiz. Author. Sergey Goder. Author. Jarod G.R. Meng. Author, maintainer. Thomas J. Leeper. Contributor. John Myles White. Contributor.","code":""},{"path":"https://github.com/prestodb/RPresto/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Filiz O, Goder S, Meng J (2022). RPresto: DBI Connector Presto. R package version 1.4.0, https://github.com/prestodb/RPresto.","code":"@Manual{,   title = {RPresto: DBI Connector to Presto},   author = {Onur Ismail Filiz and Sergey Goder and Jarod G.R. Meng},   year = {2022},   note = {R package version 1.4.0},   url = {https://github.com/prestodb/RPresto}, }"},{"path":"https://github.com/prestodb/RPresto/backend-implementations.html","id":null,"dir":"","previous_headings":"","what":"RPresto’s implmentation of DBI and dplyr backends","title":"RPresto’s implmentation of DBI and dplyr backends","text":"two main layers RPresto’s code: DBI backend dplyr remote database backend mainly using dbplyr.","code":""},{"path":"https://github.com/prestodb/RPresto/backend-implementations.html","id":"dbi-backend","dir":"","previous_headings":"","what":"DBI backend","title":"RPresto’s implmentation of DBI and dplyr backends","text":"Important classes: Important methods:","code":""},{"path":"https://github.com/prestodb/RPresto/backend-implementations.html","id":"dplyr-remote-database-backend","dir":"","previous_headings":"","what":"dplyr remote database backend","title":"RPresto’s implmentation of DBI and dplyr backends","text":"dplyr generics: dplyr remote database source functions: dbplyr generics:","code":""},{"path":"https://github.com/prestodb/RPresto/index.html","id":"rpresto","dir":"","previous_headings":"","what":"DBI Connector to Presto","title":"DBI Connector to Presto","text":"RPresto DBI-based adapter open source distributed SQL query engine Presto running interactive analytic queries.","code":""},{"path":"https://github.com/prestodb/RPresto/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"DBI Connector to Presto","text":"RPresto CRAN github. CRAN version, can use can install development version RPresto GitHub :","code":"install.packages(\"RPresto\") # install.packages(\"devtools\") devtools::install_github(\"prestodb/RPresto\")"},{"path":"https://github.com/prestodb/RPresto/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"DBI Connector to Presto","text":"following examples assume -memory Presto server set locally. ’s simplest server stores data metadata RAM workers discarded Presto restarts. don’t one set , please refer memory connector documentation. two levels APIs: DBI dplyr.","code":"# Load libaries and connect to Presto library(RPresto) library(DBI)  con <- DBI::dbConnect(   drv = RPresto::Presto(),   host = \"http://localhost\",   port = 8080,   user = Sys.getenv(\"USER\"),   catalog = \"memory\",   schema = \"default\" )"},{"path":"https://github.com/prestodb/RPresto/index.html","id":"dbi-apis","dir":"","previous_headings":"Usage","what":"DBI APIs","title":"DBI Connector to Presto","text":"easiest flexible way executing SELECT query using dbGetQuery() call. returns query result tibble. dbWriteTable() can used write small data frame Presto table. dbExistsTable() checks table exists. dbReadTable() reads entire table R. ’s essentially SELECT * query table. dbRemoveTable() drops table Presto. can execute statement returns number rows affected using dbExecute(). dbExecute() returns number rows affected statement. Since CREATE TABLE statement creates empty table, returns 0. Since 2 rows inserted table, returns 2.","code":"DBI::dbGetQuery(con, \"SELECT CAST(3.14 AS DOUBLE) AS pi\") #> # A tibble: 1 × 1 #>      pi #>   <dbl> #> 1  3.14 # Writing iris data frame into Presto DBI::dbWriteTable(con, \"iris\", iris) DBI::dbExistsTable(con, \"iris\") #> [1] TRUE DBI::dbReadTable(con, \"iris\") #> # A tibble: 150 × 5 #>    sepal.length sepal.width petal.length petal.width species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          5.1         3.5          1.4         0.2 setosa  #>  2          4.9         3            1.4         0.2 setosa  #>  3          4.7         3.2          1.3         0.2 setosa  #>  4          4.6         3.1          1.5         0.2 setosa  #>  5          5           3.6          1.4         0.2 setosa  #>  6          5.4         3.9          1.7         0.4 setosa  #>  7          4.6         3.4          1.4         0.3 setosa  #>  8          5           3.4          1.5         0.2 setosa  #>  9          4.4         2.9          1.4         0.2 setosa  #> 10          4.9         3.1          1.5         0.1 setosa  #> # … with 140 more rows DBI::dbRemoveTable(con, \"iris\") # Create an empty table using CREATE TABLE DBI::dbExecute(   con, \"CREATE TABLE testing_table (field1 BIGINT, field2 VARCHAR)\" ) #> [1] 0 DBI::dbExecute(   con,   \"INSERT INTO testing_table VALUES (1, 'abc'), (2, 'xyz')\" ) #> [1] 2 # Check the previous INSERT statment works DBI::dbReadTable(con, \"testing_table\") #> # A tibble: 2 × 2 #>   field1 field2 #>    <int> <chr>  #> 1      1 abc    #> 2      2 xyz"},{"path":"https://github.com/prestodb/RPresto/index.html","id":"dplyr-apis","dir":"","previous_headings":"Usage","what":"dplyr APIs","title":"DBI Connector to Presto","text":"also include dplyr database backend integration (mainly implemented using dbplyr package). can use dplyr::copy_to() write local data frame PrestoConnection immediately create remote table . dplyr::tbl() also work directly PrestoConnection.","code":"# Load packages library(dplyr) library(dbplyr) # Add mtcars to Presto if (DBI::dbExistsTable(con, \"mtcars\")) {   DBI::dbRemoveTable(con, \"mtcars\") } tbl.mtcars <- dplyr::copy_to(dest = con, df = mtcars, name = \"mtcars\") # colnames() gives the column names tbl.mtcars %>% colnames() #>  [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\" #> [11] \"carb\" # Treat \"iris\" in Presto as a remote data source that dplyr can now manipulate if (!DBI::dbExistsTable(con, \"iris\")) {   DBI::dbWriteTable(con, \"iris\", iris) } tbl.iris <- dplyr::tbl(con, \"iris\")  tbl.iris %>% colnames() #> [1] \"sepal.length\" \"sepal.width\"  \"petal.length\" \"petal.width\"  \"species\"  # dplyr verbs can be applied onto the remote data source tbl.iris %>%   group_by(species) %>%   summarize(     mean_sepal_length = mean(sepal.length, na.rm = TRUE)   ) %>%   arrange(species) %>%   collect() #> # A tibble: 3 × 2 #>   species    mean_sepal_length #>   <chr>                  <dbl> #> 1 setosa                  5.01 #> 2 versicolor              5.94 #> 3 virginica               6.59"},{"path":"https://github.com/prestodb/RPresto/index.html","id":"bigint-handling","dir":"","previous_headings":"Usage","what":"BIGINT handling","title":"DBI Connector to Presto","text":"RPresto’s handling BIGINT (.e. 64-bit integers) similar DBI packages (e.g. bigrquery, RPostgres). provide bigint argument users can use multiple interfaces specify want BIGINT typed data translated R. bigint argument takes one following 4 possible values. bigint = \"integer\" default setting. translates BIGINT R’s native integer type (.e. 32-bit integer). range 32-bit integer [-2,147,483,648, 2,147,483,647] cover integer use cases. case need represent integer values outside 32-bit integer range, 2 options: bigint = \"numeric\" translates number double floating-point type R; bigint = \"integer64\" packages number using bit64::integer64 class. Note two approaches actually precision-preservation range: +/-(2^53-1) = +/-9,007,199,254,740,991, due fact Presto REST API uses JSON encode number JSON limit 53 bits (rather 64 bits). bigint = \"character\" casts number string. useful BIGINT used represent ID rather real arithmetic number.","code":""},{"path":"https://github.com/prestodb/RPresto/index.html","id":"where-to-use-bigint","dir":"","previous_headings":"Usage > BIGINT handling","what":"Where to use bigint","title":"DBI Connector to Presto","text":"DBI interface function dbGetQuery() fundamental interface whereby bigint can specified. interfaces either built top dbGetQuery() take effect used dbGetQuery(). used dplyr interface, bigint can specified two places. Users can pass bigint argument dbConnect() creating PrestoConnection. queries use connection later use specified bigint setting. want specify bigint particular query using dplyr interface without affecting queries, can pass bigint collect() call.","code":"# BIGINT within the 32-bit integer range is simply translated into integer DBI::dbGetQuery(con, \"SELECT CAST(1 AS BIGINT) AS small_bigint\") #> # A tibble: 1 × 1 #>   small_bigint #>          <int> #> 1            1  # BIGINT outside of the 32-bit integer range generates a warning and returns NA # when bigint is not specified DBI::dbGetQuery(con, \"SELECT CAST(POW(2, 31) AS BIGINT) AS overflow_bigint\") #> Warning in as.integer.integer64(x): NAs produced by integer overflow #> # A tibble: 1 × 1 #>   overflow_bigint #>             <int> #> 1              NA  # Using bigint to specify numeric or integer64 translations DBI::dbGetQuery(   con, \"SELECT CAST(POW(2, 31) AS BIGINT) AS bigint_numeric\",   bigint = \"numeric\" ) #> # A tibble: 1 × 1 #>   bigint_numeric #>            <dbl> #> 1     2147483648 DBI::dbGetQuery(   con, \"SELECT CAST(POW(2, 31) AS BIGINT) AS bigint_integer64\",   bigint = \"integer64\" ) #> # A tibble: 1 × 1 #>   bigint_integer64 #>            <int64> #> 1       2147483648 con.bigint <- DBI::dbConnect(   drv = RPresto::Presto(),   host = \"http://localhost\",   port = 8080,   user = Sys.getenv(\"USER\"),   catalog = \"memory\",   schema = \"default\",   # bigint can be specified in dbConnect   bigint = \"integer64\" )  # BIGINT outside of the 32-bit integer range is automatically translated to # integer64, per the connection setting earlier DBI::dbGetQuery(   con.bigint, \"SELECT CAST(POW(2, 31) AS BIGINT) AS bigint_integer64\" ) #> # A tibble: 1 × 1 #>   bigint_integer64 #>            <int64> #> 1       2147483648 tbl.bigint <- dplyr::tbl(   con, sql(\"SELECT CAST(POW(2, 31) AS BIGINT) AS bigint\") )  # Default collect() generates a warning and returns NA dplyr::collect(tbl.bigint) #> Warning in as.integer.integer64(x): NAs produced by integer overflow #> # A tibble: 1 × 1 #>   bigint #>    <int> #> 1     NA  # Passing bigint to collect() specifies BIGINT treatment dplyr::collect(tbl.bigint, bigint = \"integer64\") #> # A tibble: 1 × 1 #>       bigint #>      <int64> #> 1 2147483648"},{"path":"https://github.com/prestodb/RPresto/index.html","id":"connecting-to-trino","dir":"","previous_headings":"","what":"Connecting to Trino","title":"DBI Connector to Presto","text":"connect Trino must set use.trino.headers parameter RPresto knows send correct headers server. Otherwise functionality supported.","code":"con.trino <- DBI::dbConnect(   RPresto::Presto(),   use.trino.headers = TRUE,   host = \"http://localhost\",   port = 8080,   user = Sys.getenv(\"USER\"),   schema = \"<schema>\",   catalog = \"<catalog>\",   source = \"<source>\" )"},{"path":"https://github.com/prestodb/RPresto/index.html","id":"passing-extra-credentials-to-the-connector","dir":"","previous_headings":"","what":"Passing extra credentials to the connector","title":"DBI Connector to Presto","text":"pass extraCredentials gets added X-Presto-Extra-Credential header use extra.credentials parameter RPresto add header creating PrestoConnection. Set use.trino.headers want pass extraCredentials X-Trino-Extra-Credential header.","code":"con <- DBI::dbConnect(   RPresto::Presto(),   host = \"http://localhost\",   port = 7777,   user = Sys.getenv(\"USER\"),   schema = \"<schema>\",   catalog = \"<catalog>\",   source = \"<source>\",   extra.credentials = \"test.token.foo=bar\", )"},{"path":"https://github.com/prestodb/RPresto/index.html","id":"how-rpresto-works","dir":"","previous_headings":"","what":"How RPresto works","title":"DBI Connector to Presto","text":"Presto exposes interface via REST based API1. utilize httr package make API calls use jsonlite reshape data tibble. RPresto tested Presto 0.100.","code":""},{"path":"https://github.com/prestodb/RPresto/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"DBI Connector to Presto","text":"RPresto BSD-licensed.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/Presto.html","id":null,"dir":"Reference","previous_headings":"","what":"Connect to a Presto database — Presto","title":"Connect to a Presto database — Presto","text":"Connect Presto database","code":""},{"path":"https://github.com/prestodb/RPresto/reference/Presto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Connect to a Presto database — Presto","text":"","code":"Presto(...)  # S4 method for PrestoDriver dbConnect(   drv,   catalog,   schema,   user,   host = \"localhost\",   port = 8080,   source = methods::getPackageName(),   session.timezone = \"\",   output.timezone = \"\",   parameters = list(),   ctes = list(),   request.config = httr::config(),   use.trino.headers = FALSE,   extra.credentials = \"\",   bigint = c(\"integer\", \"integer64\", \"numeric\", \"character\"),   ... )  # S4 method for PrestoConnection dbDisconnect(conn)"},{"path":"https://github.com/prestodb/RPresto/reference/Presto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connect to a Presto database — Presto","text":"... currently ignored drv driver object generated Presto() catalog catalog used schema schema used user current user host presto host connect port Port use connection source Source specify connection session.timezone Time zone Presto server. Presto returns timestamps without time zones respect value. time arithmetic (e.g. adding hours) also done given time zone. value passed Presto server via request headers. output.timezone time zone using TIME TZ TIMESTAMP values output represented. Default Presto server timezone (use show(<PrestoConnection>) see). parameters list() extra parameters passed ‘X-Presto-Session’ header ctes list common table expressions (CTEs) can used clause. See vignette(\"common-table-expressions\"). request.config optional config list, returned httr::config(), sent every HTTP request. use.trino.headers boolean indicate whether Trino request headers used. Default FALSE. extra.credentials Extra credentials passed X-Presto-Extra-Credential X-Trino-Extra-Credential header ( depending value use.trino.headers argument). Default empty string. bigint R type Presto's 64-bit integer (BIGINT) class translated . default \"integer\", returns R's integer type, results NA values /+/-2147483647. \"integer64\" returns bit64::integer64, allows full range 64 bit integers. \"numeric\" coerces R's double type might result precision loss. Lastly, \"character\" casts R's character type. conn PrestoConnection object","code":""},{"path":"https://github.com/prestodb/RPresto/reference/Presto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Connect to a Presto database — Presto","text":"Presto PrestoDriver object dbConnect PrestoConnection object dbDisconnect logical() value indicating success","code":""},{"path":"https://github.com/prestodb/RPresto/reference/Presto.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Connect to a Presto database — Presto","text":"","code":"if (FALSE) { conn <- dbConnect(Presto(),   catalog = \"hive\", schema = \"default\",   user = \"onur\", host = \"localhost\", port = 8080,   session.timezone = \"US/Eastern\", bigint = \"character\" ) dbListTables(conn, \"%_iris\") dbDisconnect(conn) }"},{"path":"https://github.com/prestodb/RPresto/reference/PrestoConnection-class.html","id":null,"dir":"Reference","previous_headings":"","what":"S4 implementation of DBIConnection for Presto. — PrestoConnection-class","title":"S4 implementation of DBIConnection for Presto. — PrestoConnection-class","text":"S4 implementation DBIConnection Presto.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/PrestoConnection-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"S4 implementation of DBIConnection for Presto. — PrestoConnection-class","text":"","code":"# S4 method for PrestoConnection show(object)  # S4 method for PrestoConnection dbCreateTable(   conn,   name,   fields,   with = NULL,   ...,   row.names = NULL,   temporary = FALSE )  # S4 method for PrestoConnection dbCreateTableAs(conn, name, sql, overwrite = FALSE, with = NULL, ...)  # S4 method for PrestoConnection,character dbExistsTable(conn, name, ...)  # S4 method for PrestoConnection,character dbGetQuery(conn, statement, ...)  # S4 method for PrestoConnection,character dbListFields(conn, name, ...)  # S4 method for PrestoConnection dbListTables(conn, pattern, ...)  # S4 method for PrestoConnection,character dbRemoveTable(conn, name, ..., fail_if_missing = TRUE)  # S4 method for PrestoConnection,character dbSendQuery(conn, statement, ...)  # S4 method for PrestoConnection,character,data.frame dbWriteTable(   conn,   name,   value,   overwrite = FALSE,   ...,   append = FALSE,   field.types = NULL,   temporary = FALSE,   row.names = FALSE,   with = NULL )  # S4 method for PrestoConnection sqlCreateTable(   con,   table,   fields,   row.names = NA,   temporary = FALSE,   with = NULL,   ... )  # S4 method for PrestoConnection sqlCreateTableAs(con, name, sql, with = NULL, ...)"},{"path":"https://github.com/prestodb/RPresto/reference/PrestoConnection-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"S4 implementation of DBIConnection for Presto. — PrestoConnection-class","text":"conn DBIConnection object, returned dbConnect(). name table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. \"table_name\", call Id() components fully qualified table name, e.g. Id(schema = \"my_schema\", table = \"table_name\") call SQL() quoted fully qualified table name given verbatim, e.g. SQL('\"my_schema\".\"table_name\"') fields Either character vector data frame. named character vector: Names column names, values types. Names escaped dbQuoteIdentifier(). Field types unescaped. data frame: field types generated using dbDataType(). optional clause CREATE TABLE statement. ... parameters passed methods. overwrite logical specifying whether overwrite existing table . default FALSE. pattern optional SQL pattern filtering table names, e.g. '%test%' fail_if_missing FALSE, dbRemoveTable() succeeds table exist. value data.frame (coercible data.frame). append, field.types, temporary, row.names Ignored. Included compatibility generic. con database connection. table table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. \"table_name\", call Id() components fully qualified table name, e.g. Id(schema = \"my_schema\", table = \"table_name\") call SQL() quoted fully qualified table name given verbatim, e.g. SQL('\"my_schema\".\"table_name\"')","code":""},{"path":"https://github.com/prestodb/RPresto/reference/PrestoDriver-class.html","id":null,"dir":"Reference","previous_headings":"","what":"An S4 class to represent a Presto Driver (and methods)\nIt is used purely for dispatch and dbUnloadDriver is unnecessary — PrestoDriver-class","title":"An S4 class to represent a Presto Driver (and methods)\nIt is used purely for dispatch and dbUnloadDriver is unnecessary — PrestoDriver-class","text":"S4 class represent Presto Driver (methods) used purely dispatch dbUnloadDriver unnecessary","code":""},{"path":"https://github.com/prestodb/RPresto/reference/PrestoDriver-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An S4 class to represent a Presto Driver (and methods)\nIt is used purely for dispatch and dbUnloadDriver is unnecessary — PrestoDriver-class","text":"","code":"# S4 method for PrestoDriver show(object)  # S4 method for PrestoDriver dbUnloadDriver(drv, ...)"},{"path":"https://github.com/prestodb/RPresto/reference/PrestoQuery-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class to encapsulate a Presto query — PrestoQuery-class","title":"Class to encapsulate a Presto query — PrestoQuery-class","text":"reference class (object can passed reference modified) encapsulates lifecycle Presto query inception (providing PrestoConnection query statement) steps takes execute (.e. initial POST request subsequent GET requests).","code":""},{"path":"https://github.com/prestodb/RPresto/reference/PrestoQuery-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class to encapsulate a Presto query — PrestoQuery-class","text":"similar PrestoQuery class defined Presto Python client","code":""},{"path":"https://github.com/prestodb/RPresto/reference/PrestoQuery-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class to encapsulate a Presto query — PrestoQuery-class","text":".conn PrestoConnection object .statement query statement .id query ID returned first POST request .timestamp timestamp query execution .bigint BIGINT fields converted R class .state query state. changes every time query advances next stage .next.uri URI specifies next endpoint send GET request .info.uri information URI .stats Query stats. changes every time query advances next stage .response HTTP request response. changes query advances .content Parsed content HTTP request response .fetched.row.count many rows data fetched R .post.data.fetched boolean flag indicating data returned POST request fetched","code":""},{"path":"https://github.com/prestodb/RPresto/reference/PrestoResult-class.html","id":null,"dir":"Reference","previous_headings":"","what":"An S4 class to represent a Presto Result — PrestoResult-class","title":"An S4 class to represent a Presto Result — PrestoResult-class","text":"S4 class represent Presto Result","code":""},{"path":"https://github.com/prestodb/RPresto/reference/PrestoResult-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An S4 class to represent a Presto Result — PrestoResult-class","text":"","code":"# S4 method for PrestoResult show(object)  # S4 method for PrestoResult dbClearResult(res, ...)  # S4 method for PrestoResult,numeric dbFetch(res, n)  # S4 method for PrestoResult,missing dbFetch(res)  # S4 method for PrestoResult dbGetRowCount(res, ...)  # S4 method for PrestoResult dbGetRowsAffected(res)  # S4 method for PrestoResult dbGetStatement(res, ...)  # S4 method for PrestoResult dbHasCompleted(res, ...)  # S4 method for PrestoResult dbIsValid(dbObj, ...)  # S4 method for PrestoResult,missing dbListFields(conn, name)  # S4 method for PrestoResult,integer fetch(res, n = -1, ...)  # S4 method for PrestoResult,numeric fetch(res, n = -1, ...)  # S4 method for PrestoResult,missing fetch(res)"},{"path":"https://github.com/prestodb/RPresto/reference/PrestoResult-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"An S4 class to represent a Presto Result — PrestoResult-class","text":"statement SQL statement sent database connection connection object associated result query internal implementation detail keeping track stage request post.data data extracted POST request response bigint bigint type handled","code":""},{"path":"https://github.com/prestodb/RPresto/reference/PrestoSession-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class to encapsulate a Presto session — PrestoSession-class","title":"Class to encapsulate a Presto session — PrestoSession-class","text":"session contains temporary attributes information useful session. attached PrestoConnection long connection lives. types information stored. Session properties can set via query response headers need sent following HTTP requests. Common table expressions (CTEs) can used store subquery used statement.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/PrestoSession-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class to encapsulate a Presto session — PrestoSession-class","text":".parameters List Presto session parameters added X-Presto-Session header. .ctes List common table expressions (CTEs), .e. SELECT statements names. can used statement.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/RPresto-package.html","id":null,"dir":"Reference","previous_headings":"","what":"RPresto: DBI Connector to Presto — RPresto-package","title":"RPresto: DBI Connector to Presto — RPresto-package","text":"Implements 'DBI' compliant interface Presto. Presto open source distributed SQL query engine running interactive analytic queries data sources sizes ranging gigabytes petabytes: https://prestodb.io/.","code":""},{"path":[]},{"path":"https://github.com/prestodb/RPresto/reference/RPresto-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"RPresto: DBI Connector to Presto — RPresto-package","text":"Maintainer: Jarod G.R. Meng jarodm@fb.com Authors: Onur Ismail Filiz onur@fb.com Sergey Goder sgoder@fb.com contributors: Thomas J. Leeper thomasleeper@fb.com [contributor] John Myles White johnmyleswhite@fb.com [contributor]","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbCreateTableAs.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a table in database using a statement — dbCreateTableAs","title":"Create a table in database using a statement — dbCreateTableAs","text":"Create table database using statement","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbCreateTableAs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a table in database using a statement — dbCreateTableAs","text":"","code":"dbCreateTableAs(conn, name, sql, overwrite = FALSE, with = NULL, ...)"},{"path":"https://github.com/prestodb/RPresto/reference/dbCreateTableAs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a table in database using a statement — dbCreateTableAs","text":"conn DBIConnection object, returned dbConnect(). name table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. \"table_name\", call Id() components fully qualified table name, e.g. Id(schema = \"my_schema\", table = \"table_name\") call SQL() quoted fully qualified table name given verbatim, e.g. SQL('\"my_schema\".\"table_name\"') sql character string containing SQL statement. overwrite boolean indicating existing table overwritten. Default FALSE. optional clause CREATE TABLE statement. ... parameters passed methods.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbDataType.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the corresponding presto data type for the given R object — dbDataType,PrestoDriver-method","title":"Return the corresponding presto data type for the given R object — dbDataType,PrestoDriver-method","text":"Return corresponding presto data type given R object","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbDataType.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the corresponding presto data type for the given R object — dbDataType,PrestoDriver-method","text":"","code":"# S4 method for PrestoDriver dbDataType(dbObj, obj, ...)"},{"path":"https://github.com/prestodb/RPresto/reference/dbDataType.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the corresponding presto data type for the given R object — dbDataType,PrestoDriver-method","text":"dbObj PrestoDriver object obj R object ... Extra optional parameters, currently used","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbDataType.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the corresponding presto data type for the given R object — dbDataType,PrestoDriver-method","text":"character value corresponding Presto type obj","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbDataType.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Return the corresponding presto data type for the given R object — dbDataType,PrestoDriver-method","text":"default value unknown classes ‘VARCHAR’. ‘ARRAY’s ‘MAP’s supported caveats. Unnamed lists treated ‘ARRAY’s named lists ‘MAP’. items expected corresponding Presto type, otherwise default ‘VARCHAR’ value returned. key type ‘MAP’s always ‘VARCHAR’. ‘value’ type empty lists always ‘VARCHAR’.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbDataType.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the corresponding presto data type for the given R object — dbDataType,PrestoDriver-method","text":"","code":"drv <- RPresto::Presto() dbDataType(drv, list()) #> [1] \"ARRAY<VARCHAR>\" dbDataType(drv, 1) #> [1] \"DOUBLE\" dbDataType(drv, NULL) #> [1] \"VARCHAR\" dbDataType(drv, list(list(list(a = Sys.Date())))) #> [1] \"ARRAY<ARRAY<MAP<VARCHAR, DATE>>>\" dbDataType(drv, as.POSIXct(\"2015-03-01 00:00:00\", tz = \"UTC\")) #> [1] \"TIMESTAMP WITH TIME ZONE\" dbDataType(drv, Sys.time()) #> [1] \"TIMESTAMP\" # Data types for ARRAY or MAP values can be tricky all.equal(\"VARCHAR\", dbDataType(drv, list(1, 2, 3L))) #> [1] TRUE"},{"path":"https://github.com/prestodb/RPresto/reference/dbGetInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Metadata about database objects — dbGetInfo,PrestoDriver-method","title":"Metadata about database objects — dbGetInfo,PrestoDriver-method","text":"Metadata database objects PrestoResult object, implementation returns additional stats field can used implement things like progress bars. See examples section.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbGetInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metadata about database objects — dbGetInfo,PrestoDriver-method","text":"","code":"# S4 method for PrestoDriver dbGetInfo(dbObj)  # S4 method for PrestoConnection dbGetInfo(dbObj)  # S4 method for PrestoResult dbGetInfo(dbObj)"},{"path":"https://github.com/prestodb/RPresto/reference/dbGetInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metadata about database objects — dbGetInfo,PrestoDriver-method","text":"dbObj PrestoDriver, PrestoConnection PrestoResult object","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbGetInfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metadata about database objects — dbGetInfo,PrestoDriver-method","text":"PrestoResult list() elements statement SQL sent database row.count Number rows fetched far .completed Whether data fetched stats Current stats query","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbGetInfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Metadata about database objects — dbGetInfo,PrestoDriver-method","text":"","code":"if (FALSE) { conn <- dbConnect(Presto(), \"localhost\", 7777, \"onur\", \"datascience\") result <- dbSendQuery(conn, \"SELECT * FROM jonchang_iris\") iris <- data.frame() progress.bar <- NULL while (!dbHasCompleted(result)) {   chunk <- dbFetch(result)   if (!NROW(iris)) {     iris <- chunk   } else if (NROW(chunk)) {     iris <- rbind(iris, chunk)   }   stats <- dbGetInfo(result)[[\"stats\"]]   if (is.null(progress.bar)) {     progress.bar <- txtProgressBar(0, stats[[\"totalSplits\"]], style = 3)   } else {     setTxtProgressBar(progress.bar, stats[[\"completedSplits\"]])   } } close(progress.bar) }"},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr-db.html","id":null,"dir":"Reference","previous_headings":"","what":"dbplyr database methods — db_list_tables.PrestoConnection","title":"dbplyr database methods — db_list_tables.PrestoConnection","text":"dbplyr database methods","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr-db.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dbplyr database methods — db_list_tables.PrestoConnection","text":"","code":"# S3 method for PrestoConnection db_list_tables(con)  # S3 method for PrestoConnection db_has_table(con, table)  # S3 method for PrestoConnection db_write_table(   con,   table,   types,   values,   temporary = FALSE,   overwrite = FALSE,   ...,   with = NULL )  # S3 method for PrestoConnection db_copy_to(   con,   table,   values,   overwrite = FALSE,   types = NULL,   temporary = TRUE,   unique_indexes = NULL,   indexes = NULL,   analyze = TRUE,   ...,   in_transaction = TRUE,   with = NULL )  # S3 method for PrestoConnection db_compute(   con,   table,   sql,   temporary = TRUE,   unique_indexes = list(),   indexes = list(),   analyze = TRUE,   with = NULL,   ... )  # S3 method for PrestoConnection db_sql_render(con, sql, ..., use_presto_cte = TRUE)"},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr-db.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dbplyr database methods — db_list_tables.PrestoConnection","text":"con PrestoConnection returned dbConnect(). table Table name types used. NULL accpeted. values data.frame. temporary temporary table used. supported. FALSE accepted. overwrite existing table overwritten. ... Extra arguments passed individual methods. optional clause CREATE TABLE statement. unique_indexes, indexes, analyze, in_transaction Ignored. Included compatibility generics. sql SQL statement. use_presto_cte logical value indicating use common table expressions stored PrestoConnection possible. Default TRUE. See vignette(\"common-table-expressions\").","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr-sql.html","id":null,"dir":"Reference","previous_headings":"","what":"dbplyr SQL methods — sql_query_save.PrestoConnection","title":"dbplyr SQL methods — sql_query_save.PrestoConnection","text":"dbplyr SQL methods","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr-sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dbplyr SQL methods — sql_query_save.PrestoConnection","text":"","code":"# S3 method for PrestoConnection sql_query_save(con, sql, name, temporary = TRUE, ..., with = NULL)"},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr-sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dbplyr SQL methods — sql_query_save.PrestoConnection","text":"con database connection. sql character string containing SQL statement. name table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. \"table_name\", call Id() components fully qualified table name, e.g. Id(schema = \"my_schema\", table = \"table_name\") call SQL() quoted fully qualified table name given verbatim, e.g. SQL('\"my_schema\".\"table_name\"') temporary temporary table created. Default TRUE dbplyr::sql_query_save() generic. default value generates error Presto. Using temporary = FALSE save query permanent table. ... arguments used individual methods. optional clause CREATE TABLE statement.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr_edition.PrestoConnection.html","id":null,"dir":"Reference","previous_headings":"","what":"Inform the dbplyr version used in this package — dbplyr_edition.PrestoConnection","title":"Inform the dbplyr version used in this package — dbplyr_edition.PrestoConnection","text":"Inform dbplyr version used package","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr_edition.PrestoConnection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inform the dbplyr version used in this package — dbplyr_edition.PrestoConnection","text":"","code":"# S3 method for PrestoConnection dbplyr_edition(con)"},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr_edition.PrestoConnection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inform the dbplyr version used in this package — dbplyr_edition.PrestoConnection","text":"con DBIConnection object.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr_function_implementations.html","id":null,"dir":"Reference","previous_headings":"","what":"S3 implementation of sql_query_fields for Presto. — sql_query_fields.PrestoConnection","title":"S3 implementation of sql_query_fields for Presto. — sql_query_fields.PrestoConnection","text":"S3 implementation sql_query_fields Presto. S3 implementation custom escape method sql_escape_date S3 implementation custom escape method sql_escape_datetime S3 implementation sql_translation Presto.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dbplyr_function_implementations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"S3 implementation of sql_query_fields for Presto. — sql_query_fields.PrestoConnection","text":"","code":"# S3 method for PrestoConnection sql_query_fields(con, sql, ...)  # S3 method for PrestoConnection sql_escape_date(con, x)  # S3 method for PrestoConnection sql_escape_datetime(con, x)  # S3 method for PrestoConnection sql_translation(con)"},{"path":"https://github.com/prestodb/RPresto/reference/dplyr_function_implementations.html","id":null,"dir":"Reference","previous_headings":"","what":"S3 implementation of db_desc for Presto. — db_desc.PrestoConnection","title":"S3 implementation of db_desc for Presto. — db_desc.PrestoConnection","text":"S3 implementation db_desc Presto. S3 implementation dplyr::db_data_type() Presto. S3 implementation dplyr::db_explain() Presto. S3 implementation dplyr::db_query_rows() Presto. S3 implementation db_collect Presto. S3 implementation collect Presto. S3 implementation compute Presto.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dplyr_function_implementations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"S3 implementation of db_desc for Presto. — db_desc.PrestoConnection","text":"","code":"# S3 method for PrestoConnection db_desc(x)  # S3 method for PrestoConnection db_data_type(con, fields, ...)  # S3 method for PrestoConnection db_explain(con, sql, ...)  # S3 method for PrestoConnection db_query_rows(con, sql)  # S3 method for PrestoConnection db_collect(con, sql, n = -1, warn_incomplete = TRUE, ...)  # S3 method for tbl_presto collect(x, ..., n = Inf, warn_incomplete = TRUE)  # S3 method for tbl_presto compute(x, name, temporary = FALSE, ..., cte = FALSE)"},{"path":"https://github.com/prestodb/RPresto/reference/dplyr_function_implementations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"S3 implementation of db_desc for Presto. — db_desc.PrestoConnection","text":"x lazy data frame backed database query. cte experimental feature save query common table expression. Default FALSE. See vignette(\"common-table-expressions\")","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dplyr_source_function_implementations.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr integration to connect to a table in a database. — tbl.src_presto","title":"dplyr integration to connect to a table in a database. — tbl.src_presto","text":"Use src_presto connect existing database, tbl connect tables within database. unsure arguments pass, please ask database administrator values variables. Automatically create Presto remote database source wrap aroudn PrestoConnection object via DBI APIs can called.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dplyr_source_function_implementations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr integration to connect to a table in a database. — tbl.src_presto","text":"","code":"# S3 method for src_presto tbl(src, from, ..., vars = NULL)  # S3 method for PrestoConnection tbl(conn, from, ...)  # S3 method for src_presto copy_to(   dest,   df,   name = deparse(substitute(df)),   overwrite = FALSE,   ...,   with = NULL )  # S3 method for PrestoConnection copy_to(   dest,   df,   name = deparse(substitute(df)),   overwrite = FALSE,   ...,   with = NULL )"},{"path":"https://github.com/prestodb/RPresto/reference/dplyr_source_function_implementations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr integration to connect to a table in a database. — tbl.src_presto","text":"src presto src created src_presto. Either string (giving table name) literal dbplyr::sql() string. ... Passed dbplyr::tbl_sql() vars Provide column names character vector avoid retrieving database. conn PrestoConnection object produced DBI::dbConnect(). dest remote data source df local data frame name name new remote table. overwrite TRUE, overwrite existing table name name. FALSE, throw error name already exists. optional clause CREATE TABLE statement.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dplyr_source_function_implementations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr integration to connect to a table in a database. — tbl.src_presto","text":"","code":"if (FALSE) { # First create a database connection with src_presto, then reference a tbl # within that database my_db <- src_presto(   catalog = \"memory\",   schema = \"default\",   user = Sys.getenv(\"USER\"),   host = \"http://localhost\",   port = 8080,   session.timezone = \"Asia/Kathmandu\" ) my_tbl <- tbl(my_db, \"my_table\") } if (FALSE) { # First create a database connection, then reference a tbl within that # database my_con <- DBI::dbConnect(   catalog = \"memory\",   schema = \"default\",   user = Sys.getenv(\"USER\"),   host = \"http://localhost\",   port = 8080,   session.timezone = \"Asia/Kathmandu\" ) my_tbl <- tbl(my_con, \"my_table\") }"},{"path":"https://github.com/prestodb/RPresto/reference/dummy_tables.html","id":null,"dir":"Reference","previous_headings":"","what":"Create dummy tables in Presto for testing — dummy_tables","title":"Create dummy tables in Presto for testing — dummy_tables","text":"create_primitive_arrays_table() creates dummy table ARRAYs primitive Presto data types. create_primitive_maps_table() creates dummy table MAPs primitive Presto data types. create_primitive_types_table() creates dummy table primitive Presto data types. create_primitive_rows_table() creates dummy table primitive data types included one ROW type column. create_array_of_rows_table() creates dummy table ARRAY(ROW) column 2 ROW elements, containing 17 supported primitive data types. create_array_of_maps_table() creates dummy table 17 ARRAY(MAP) columns, ARRAY 2 MAP elements.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dummy_tables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create dummy tables in Presto for testing — dummy_tables","text":"","code":"create_primitive_arrays_table(   con,   table_name = \"presto_primitive_arrays\",   time_zone = \"America/New_York\",   verbose = TRUE )  create_primitive_maps_table(   con,   table_name = \"presto_primitive_maps\",   time_zone = \"America/New_York\",   verbose = TRUE )  create_primitive_types_table(   con,   table_name = \"presto_primitive_types\",   time_zone = \"America/New_York\",   verbose = TRUE )  create_primitive_rows_table(   con,   table_name = \"presto_primitive_rows\",   time_zone = \"America/New_York\",   verbose = TRUE )  create_array_of_rows_table(   con,   table_name = \"presto_array_of_rows\",   time_zone = \"America/New_York\",   verbose = TRUE )  create_array_of_maps_table(   con,   table_name = \"presto_array_of_maps\",   time_zone = \"America/New_York\",   verbose = TRUE )"},{"path":"https://github.com/prestodb/RPresto/reference/dummy_tables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create dummy tables in Presto for testing — dummy_tables","text":"con valid PrestoConnection object. table_name resulting table name. time_zone Time zone string data types require time zone. Default \"America/New_York\". verbose Boolean indicating whether messages printed. Default TRUE.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/dummy_tables.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create dummy tables in Presto for testing — dummy_tables","text":"construct arrays--primitive-types table putting two different values type NULL value array. way, three values type appear together source code therefore easier compare. integer values, use theoretical lower bound (.e., minimum value) theoretical upper bound (.e., maximum value) two values. field names taken Presto data types represent. complete primitive type values included table construct maps--primitive-types table first creating table ARRAYs primitive data types. use MAP() function create MAPs ARRAYs. construct primitive-types table first creating table ARRAYs primitive data types. use Presto's UNNEST() function expand arrays three separate rows. supported Presto data type three rows table resulting R data frame distinctly different simple named list. construct primitive-rows table first creating table primitive data types. use Presto's CAST(ROW() ROW()) function create ROW column. construct array--rows table first creating table ROW type column includes 17 supported primitive data types. use ARRAY[] function construct 2-element ARRAY(ROW) column. construct array--maps table first creating table primitive MAP table calling ARRAY[] function create ARRAY(MAP) columns.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/sqlCreateTableAs.html","id":null,"dir":"Reference","previous_headings":"","what":"Compose query to create a simple table using a statement — sqlCreateTableAs","title":"Compose query to create a simple table using a statement — sqlCreateTableAs","text":"Compose query create simple table using statement","code":""},{"path":"https://github.com/prestodb/RPresto/reference/sqlCreateTableAs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compose query to create a simple table using a statement — sqlCreateTableAs","text":"","code":"sqlCreateTableAs(con, name, sql, with = NULL, ...)"},{"path":"https://github.com/prestodb/RPresto/reference/sqlCreateTableAs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compose query to create a simple table using a statement — sqlCreateTableAs","text":"con database connection. name table name, passed dbQuoteIdentifier(). Options : character string unquoted DBMS table name, e.g. \"table_name\", call Id() components fully qualified table name, e.g. Id(schema = \"my_schema\", table = \"table_name\") call SQL() quoted fully qualified table name given verbatim, e.g. SQL('\"my_schema\".\"table_name\"') sql character string containing SQL statement. optional clause CREATE TABLE statement. ... arguments used individual methods.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/src_presto.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr integration to connect to a Presto database. — src_presto","title":"dplyr integration to connect to a Presto database. — src_presto","text":"Allows connect existing database presto connection.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/src_presto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr integration to connect to a Presto database. — src_presto","text":"","code":"src_presto(   catalog = NULL,   schema = NULL,   user = NULL,   host = NULL,   port = NULL,   source = NULL,   session.timezone = NULL,   parameters = NULL,   bigint = c(\"integer\", \"integer64\", \"numeric\", \"character\"),   con = NULL,   ... )"},{"path":"https://github.com/prestodb/RPresto/reference/src_presto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr integration to connect to a Presto database. — src_presto","text":"catalog Catalog use connection schema Schema use connection user User name use connection host Host name connect database port Port number use host name source Source specify connection session.timezone Time zone connection parameters Additional parameters pass connection bigint R type Presto's 64-bit integer (BIGINT) types translated . default \"integer\", returns R's integer type, results NA values /+/-2147483647. \"integer64\" returns bit64::integer64, allows full range 64 bit integers. \"numeric\" coerces R's double type might result precision loss. Lastly, \"character\" casts R's character type. con object inherits PrestoConnection, typically generated DBI::dbConnect. valid connection object supplied, arguments ignored. ... src_presto arguments passed underlying database connector dbConnect. tbl.src_presto, included compatibility generic, otherwise ignored.","code":""},{"path":"https://github.com/prestodb/RPresto/reference/src_presto.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr integration to connect to a Presto database. — src_presto","text":"","code":"if (FALSE) { # To connect to a database my_db <- src_presto(   catalog = \"memory\",   schema = \"default\",   user = Sys.getenv(\"USER\"),   host = \"http://localhost\",   port = 8080,   session.timezone = \"Asia/Kathmandu\" ) # Use a PrestoConnection my_con <- DBI::dbConnect(   catalog = \"memory\",   schema = \"default\",   user = Sys.getenv(\"USER\"),   host = \"http://localhost\",   port = 8080,   session.timezone = \"Asia/Kathmandu\" ) my_db2 <- src_presto(con = my_con) }"},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-140","dir":"Changelog","previous_headings":"","what":"RPresto 1.4.0","title":"RPresto 1.4.0","text":"Change maintainer Jarod Meng (jarodm@fb.com) output changed data.frame tibble offer better printing consistent DBI-compatible datawarehouse packages Add user-friendly R types translation primitive Presto data types (e.g., DATE types now translated Date classes R; TIMESTAMP types translated POSIXct classes; TIME types translated difftime classes; INTERVAL types translated Duration classes) Enable choices BIGINT type handling (.e., integer64, integer, numeric, character). (#61) Add complete support complex Presto types (.e., ARRAY, MAP, ROW). now translated typed vectors, lists, tibbles depending types structure data. (#118) supports primitive complex data types Trino . (#176) Add vignettes Presto-R type translations (see vignette(\"primitive-types\") vignette(\"complex-types\")) dbExistsTable() error quoted identifier supplied name fixed (#167) dbplyr::sql_query_save() dplyr::db_list_tables() dplyr::db_has_table() dplyr::db_write_table() dbplyr::db_copy_to() dplyr::copy_to() method src_presto PrestoConnection dplyr::tbl() method PrestoConnection dbplyr::db_compute() dplyr::compute() PrestoConnection gains request.config slot whereby users can set extra Curl configs (returned httr::config() GET/POST requests. (#173) Styling whole package using styler::style_pkg(). notable change user double quotes everywhere instead combination single double quotes. (#174) Add experimental feature support common table expressions (CTEs) DBI dplyr backends (see vignette(\"common-table-expressions\")) (#175) dbConnect() now uses empty string “” (rather UTC) default session.timezone translates Presto server timezone. dbConnect() src_presto() gain output.timezone argument can used control TIME TZ TIMESTAMP values represented output tibble.","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-138","dir":"Changelog","previous_headings":"","what":"RPresto 1.3.8","title":"RPresto 1.3.8","text":"Fix failing unit tests (#141) Support Trino headers session (#143) Update copyright headers Migrate RPresto’s dplyr interface use dbplyr 2.0.0 backend (#150) Add documentation RPresto’s DBI dplyr backend implementation","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-137","dir":"Changelog","previous_headings":"","what":"RPresto 1.3.7","title":"RPresto 1.3.7","text":"CRAN release: 2021-09-04 Fix testing errors caused Presto changes since last update (#131) Change [[ translation [] subscript operator ELEMENT_AT() (#132) Enable simple ROW type support (#137) Fix bug whereby .infinite() incorrectly translated IS_FINITE() instead IS_INFINITE() SQL (#139) Disabled translation median() quantile() suggested approx_quantile() instead. (#120)","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-136","dir":"Changelog","previous_headings":"","what":"RPresto 1.3.6","title":"RPresto 1.3.6","text":"CRAN release: 2021-05-31 Change maintainer Thomas Leeper (thomasleeper@fb.com)","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-135","dir":"Changelog","previous_headings":"","what":"RPresto 1.3.5","title":"RPresto 1.3.5","text":"CRAN release: 2020-11-13 Add custom Date POSIXct sql translation implementations dbplyr (#123, thanks @OssiLehtinen original implementations). Adapt dbClearResult API change, now need DELETE /v1/query/<query_id>. Add query.id slot PrestoResult.","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-134","dir":"Changelog","previous_headings":"","what":"RPresto 1.3.4","title":"RPresto 1.3.4","text":"CRAN release: 2019-10-18 Translate [[ allow indexing arrays maps dplyr (#110). Switch BSD+Patents license Standard BSD license (#114).","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-133","dir":"Changelog","previous_headings":"","what":"RPresto 1.3.3","title":"RPresto 1.3.3","text":"CRAN release: 2019-05-03 Fix tests compatibility dbplyr 1.4.0. Send headers http requests (#103). Add support .<data_type> style casting dplyr (#97). Add Code Conduct.","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-132","dir":"Changelog","previous_headings":"","what":"RPresto 1.3.2","title":"RPresto 1.3.2","text":"CRAN release: 2018-10-23 Use new delayed S3 registration mechanism 3.6.0 dplyr method implementations. Bump minimum dplyr version required 0.7.0.","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-131","dir":"Changelog","previous_headings":"","what":"RPresto 1.3.1","title":"RPresto 1.3.1","text":"CRAN release: 2018-09-10 Presto now might return data POST response (#89) Presto now might always return column information response (#93) Better error message unknown column types (#86, #87) Adapt presto changes type casting translation (#88) Add CHAR data type (#91)","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-130","dir":"Changelog","previous_headings":"","what":"RPresto 1.3.0","title":"RPresto 1.3.0","text":"CRAN release: 2017-07-13 Fix Rcpp compilation Windows (#79) SET/RESET SESSION queries now correctly respected used dbGetQuery. PrestoConnection longer parameters slot dbConnect remains backward compatible. Manual change parameter still possible via conn@session$setParameter() (#77) Adapt changes dplyr version 0.7.0, mainly around remote backend support split dbplyr. backwards compatible back dplyr 0.4.3 (#76) Add support REAL data type (#70) Allow specifying connection source (#68) Drop RCurl dependency (#67) Return DECIMAL data types characters opposed numeric’s previously (#64, fixes #60) Add support new integer data types (INTEGER, SMALLINT, TINYINT) (#59, fixes #56) Migrate json data.frame construction pure R Rcpp 10x speed gains! (thanks @saurfang) (#57, #58) Fix dbListFields use nextUri instead infoUri (#55) Don’t drop data duplicate column names (#53)","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-121","dir":"Changelog","previous_headings":"","what":"RPresto 1.2.1","title":"RPresto 1.2.1","text":"CRAN release: 2016-04-06 Handle responses column information (fixes #49) Add retries GET POST responses error status codes Skip test cases ones need locale modification set locale OS. Adapt changes upcoming dplyr testthat versions.","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-120","dir":"Changelog","previous_headings":"","what":"RPresto 1.2.0","title":"RPresto 1.2.0","text":"CRAN release: 2016-03-18 Add session.timezone parameter dbConnect src_presto defaults UTC. affects timestamps returned Presto data types “TIMESTAMP”. handle ambiguity assigning time zone every POSIXct column returned. Note .character() directly columns, values obtain different happened . Fix way handle zero row multiple column query results. affect LIMIT 0 queries specifically.","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-111","dir":"Changelog","previous_headings":"","what":"RPresto 1.1.1","title":"RPresto 1.1.1","text":"Minor dplyr related fixes Drop R version requirement 3.1.1 3.1.0 Speed-binding chunks dplyr available. Handle special values like Infinity, NaN.","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-110","dir":"Changelog","previous_headings":"","what":"RPresto 1.1.0","title":"RPresto 1.1.0","text":"Add optional dplyr support. One can initiate connection via src_presto. Minor documentation fixes.","code":""},{"path":"https://github.com/prestodb/RPresto/news/index.html","id":"rpresto-100","dir":"Changelog","previous_headings":"","what":"RPresto 1.0.0","title":"RPresto 1.0.0","text":"Initial release github","code":""}]
